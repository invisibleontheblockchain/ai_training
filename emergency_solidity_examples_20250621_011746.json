[
  {
    "prompt": "Create a basic ERC20 token contract in Solidity",
    "response": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SimpleToken {\n    string public name = \"SimpleToken\";\n    string public symbol = \"STK\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n    \n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n    constructor(uint256 _totalSupply) {\n        totalSupply = _totalSupply * 10**decimals;\n        balanceOf[msg.sender] = totalSupply;\n    }\n    \n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n    \n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value, \"Insufficient balance\");\n        require(allowance[_from][msg.sender] >= _value, \"Allowance exceeded\");\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}"
  },
  {
    "prompt": "Create a simple price oracle contract in Solidity",
    "response": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract PriceOracle {\n    address public owner;\n    mapping(string => uint256) public prices;\n    \n    event PriceUpdated(string asset, uint256 price);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this\");\n        _;\n    }\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    function setPrice(string memory _asset, uint256 _price) public onlyOwner {\n        prices[_asset] = _price;\n        emit PriceUpdated(_asset, _price);\n    }\n    \n    function getPrice(string memory _asset) public view returns (uint256) {\n        return prices[_asset];\n    }\n}"
  },
  {
    "prompt": "Create a basic lending pool contract in Solidity",
    "response": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract LendingPool {\n    mapping(address => uint256) public deposits;\n    mapping(address => uint256) public borrowed;\n    uint256 public totalLiquidity;\n    uint256 public interestRate = 5; // 5% annual\n    \n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Borrow(address indexed user, uint256 amount);\n    event Repay(address indexed user, uint256 amount);\n    \n    function deposit() public payable {\n        require(msg.value > 0, \"Deposit must be greater than 0\");\n        deposits[msg.sender] += msg.value;\n        totalLiquidity += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    \n    function withdraw(uint256 _amount) public {\n        require(deposits[msg.sender] >= _amount, \"Insufficient balance\");\n        require(address(this).balance >= _amount, \"Insufficient pool liquidity\");\n        \n        deposits[msg.sender] -= _amount;\n        totalLiquidity -= _amount;\n        payable(msg.sender).transfer(_amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n    \n    function borrow(uint256 _amount) public {\n        require(_amount > 0, \"Borrow amount must be greater than 0\");\n        require(deposits[msg.sender] * 2 >= _amount, \"Insufficient collateral\");\n        require(address(this).balance >= _amount, \"Insufficient pool liquidity\");\n        \n        borrowed[msg.sender] += _amount;\n        payable(msg.sender).transfer(_amount);\n        emit Borrow(msg.sender, _amount);\n    }\n    \n    function repay() public payable {\n        require(msg.value > 0, \"Repay amount must be greater than 0\");\n        require(borrowed[msg.sender] >= msg.value, \"Repay amount exceeds borrowed\");\n        \n        borrowed[msg.sender] -= msg.value;\n        totalLiquidity += msg.value;\n        emit Repay(msg.sender, msg.value);\n    }\n    \n    function getBalance(address _user) public view returns (uint256) {\n        return deposits[_user];\n    }\n    \n    function getBorrowed(address _user) public view returns (uint256) {\n        return borrowed[_user];\n    }\n}"
  }
]